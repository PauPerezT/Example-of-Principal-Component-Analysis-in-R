#####Implementacion de PCA#######
####Curso de Aprendizaje estadistico###
###Universidad de Antioquia####

#####Base de datos mtcars de la base de R####
#*mpg: Fuel consumption (Miles per (US) gallon): more powerful and heavier cars tend to consume more fuel.
#cyl: Number of cylinders: more powerful cars often have more cylinders
#disp: Displacement (cu.in.): the combined volume of the engine's cylinders
#hp: Gross horsepower: this is a measure of the power generated by the car
#drat: Rear axle ratio: this describes how a turn of the drive shaft corresponds to a turn of the wheels. 
      # Higher values will decrease fuel efficiency.
#wt: Weight (1000 lbs): pretty self-explanatory!
#qsec: 1/4 mile time: the cars speed and acceleration
#vs: Engine block: this denotes whether the vehicle's engine is shaped like a "V", or is a more common straight shape.
#am: Transmission: this denotes whether the car's transmission is automatic (0) or manual (1).
#gear: Number of forward gears: sports cars tend to have more gears.
#carb: Number of carburetors: associated with more powerful engines

#Librerias requeridas
library("dplyr")
library("FactoMineR")
library("factoextra")
library("ggplot2") #especial para graficar 
library("corrplot") #para una mejor interpretacion de las correlaciones
str(mtcars) #ver la estructura de los datos
mtcars <- mtcars%>%mutate_at(c("am","vs"), funs(as.factor)) 

##Calcular los componentes principales
mtcar.pca <- prcomp(mtcars[,c(1:7, 10,11)], center=TRUE, scale.=TRUE )
str(mtcar.pca) 
mtcar.pca$rotation #Matrix que contiene los eigenvectors
summary(mtcar.pca)

##Otra funcion que entrega mas detalle
mtcar.pca2 <- PCA(mtcars[,c(1:7, 10,11)], scale.unit = TRUE )

###Valores propios#####
eig.val <- get_eigenvalue(mtcar.pca); eig.val
fviz_eig(mtcar.pca, addlabels = TRUE, ylim=c(0, 70), barfill = "skyblue")

mtcar.pca$sdev #la desviacion standar de los componentes principales, la raiz cuadrada de los valores 
               #propios de la matrix de covarianza
cumpro <- cumsum(mtcar.pca$sdev^2 / sum(mtcar.pca$sdev^2))
plot(cumpro[0:length(cumpro)], xlab = "PC #", ylab = "Amount of explained variance", 
     main = "Cumulative variance plot", ylim = c(0,1))
abline(v = 3, col="blue", lty=5)
abline(h = cumpro[[3]], col="blue", lty=5)
legend("bottomright", legend=c("Cut-off @ PC3"),
       col=c("blue"), lty=2, cex=0.9)

###Obtener resultados para las variables###
var <- get_pca_var(mtcar.pca); var
var$coord  #Coordenadas de las variables para crear un scatter plot  
var$cos2  #muetra la calidad de la representacion para las variables, en el factor map
         #Se calcula como el cuadrado de las coordenadas var.cos2=var.coord x var.coord
var$contrib #contiene las contribuciones (en porcentaje) de las variables a los componentes
            #principales. (var.cos2 x 100)/(total cos2 de la componente)

###Correlacion entre la variables y un componente principal####

fviz_pca_var(mtcar.pca,col.circle='blue', repel = TRUE, col.var = 'red')
#Variables correlacionadas positivamente, se encuentran agrupadas, en 
# cuadrantes opuestos las negativas. #La distancia entre las variables y 
# el origen miden la calidad de la representacion en el mapa

corrplot(var$cos2, is.corr=FALSE) #cos2 cerca a 1, signifca que ángulo es cercano a 0, bien proyectado
fviz_cos2(mtcar.pca, choice ="var", axes = 1:2)
#Recordar que para una variable la suma de el cos2 de todas las componens principales
#es iqual a 1. Asi se observa la importancia de las dos componente en el caso del grafico
fviz_pca_var(mtcar.pca, col.var = "cos2", gradient.cols=c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
fviz_pca_var(mtcar.pca, alpha.var = "cos2")

###Contribucion de las variables para explicar los PCs###
var$contrib
corrplot(var$contrib, is.corr = FALSE) #gráfico de correlaciones
#Contribucion de las variables al PC1
fviz_contrib(mtcar.pca, choice = "var", axes = 1) #linea es la contribucion promedio esperada uniforme
fviz_contrib(mtcar.pca, choice = "var", axes = 2) #PC2
fviz_contrib(mtcar.pca, choice = "var", axes = 1:2)#PC1 y PC2
#grafico de correlacion
fviz_pca_var(mtcar.pca, col.var = "contrib", gradient.cols=c("#00AFBB", "#E7B800", "#FC4E07"))

######Graficos de individuos u observaciones######
ind<-get_pca_ind(mtcar.pca); ind
fviz_pca_ind(mtcar.pca)
fviz_pca_ind(mtcar.pca, col.ind = "cos2",gradient.cols=c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
#cambiar el tamano del punto de acuerdo al cos2 de cada observacion#
fviz_pca_ind(mtcar.pca, pointsize = "cos2",pointshape=21, fill= "#FC4E07", repel = TRUE)

fviz_cos2(mtcar.pca, choice="ind", axes = 1)
fviz_cos2(mtcar.pca, choice="ind", axes = 1:2)

##Usando una variable ordinal o nominal para ver comportamiento de los puntajes en 
##Cluster. 
fviz_pca_ind(mtcar.pca, geom.ind = "point", pointshape = 21, 
             pointsize = 2, 
             fill.ind = mtcars$am, 
             col.ind = "black", 
             palette = "jco", 
             addEllipses = TRUE,
             label = "var",
             col.var = "black",
             repel = TRUE,
             legend.title = "Type of trasmission") +
  ggtitle("2D PCA-plot") +
  theme(plot.title = element_text(hjust = 0.5))

##Como visualizar otros componetes
fviz_pca_var(mtcar.pca, axes = c(2,3))
fviz_pca_ind(mtcar.pca, axes = c(2,3))

#otras representaciones
fviz_pca_var(mtcar.pca, geom.var = c("point","text"))
fviz_pca_ind(mtcar.pca, geom.ind = "point", col.ind = mtcars$am,
             pallette="lancet", addEllipses = TRUE, legend.title='Groups')

####BIPLOT###
#indiviudos y variables#
fviz_pca_biplot(mtcar.pca, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")

####Cierre de código###
